# Структура плана запроса

## Стадии {#stages}

Давайте выполним чуть более сложный запрос и посмотрим, как это будет выглядеть в графическом представлении

```sql
SELECT count(*) cnt, l_orderkey, sum(l_quantity)
  FROM lineitem
  WHERE l_commitdate >= date("1993-01-01") and l_commitdate < date("1993-02-01")
  GROUP BY l_orderkey
  HAVING sum(l_quantity) > 200
  ORDER BY cnt DESC, l_orderkey
```

![Простая агрегация](../../_assets/rts-structure-1.svg)

Здесь показан структура графа вычислений, который получился в результате компиляции этого запроса. При компиляции запрос структурно разбивается на логические операторы. Для каждого логического оператора создаётся один или несколько физических операторов, которые объединятся в стадии выполнения запроса.

Стадия - это неделимая программа, однако из-за распределенной массивно-параллельной природы {{ ydb-short-name }} стадия может содержать более 1 задачи, которые работают параллельно, возможно на разных узлах. Поток данных передаётся от стадии к стадии и в общем случае образует DAG, но пока что у нас более простой случай, все стадии обрабатывают данные последовательно. Поток данных направлен снизу вверх, на нижнем уровне находится хранилище данных, сверху - результат выполнения запроса.

На графе отображаются стадии двух типов

1. Часть которая выполняется непосредственно в системе хранения (колоночные таблицы или шарды) выделяется более тёмным цветом
2. Часть, которая не хранит, а только обрабатывает данные (компьют) выделяется более светлым цветом, а также нумеруется последовательно, начиная с ```0```.

В приведённом примере у нас есть три вычислительные стадии ```0```, ```1``` и ```2```, а также стадия, связанная с таблицей ```lineitem``` (такие стадии не нумеруются). Кроме того, любая стадия может быть временно выделено для удобства исследования. В приведённом примере выделена стадия ```1```. Если это вдруг не так, обновите страницу, вероятно вы уже сменили выбранный элемент. Перезагрузка страницы приведёт изображения в исходное состояние.

{% note tip %}

Попробуйте прямо сейчас изменить выбранную стадию, это удобно и полезно при работе с гораздо более сложными планами, состоящими из большого количества стадий.

{% endnote %}

Если кратко описать, что происходит на этом плане, то получится следующее (напоминаем, что список на этой странице идёт сверху вниз, но данные на графике, а также операторы и стадии расположены в обратном порядке и сопоставлять этот перечень следует начиная с самом низа графика):

1. Таблица ```lineitem``` полностью сканируется (перебираются все строки), потому что условие ```WHERE``` не использует первичный ключ данной таблицы
2. Данные фильтруются по условия относительно поля ```l_commitdate```, это происходит непосредственно в месте хранения (пушдаун предиката) для экономии объема передаваемых данных
3. В стадии ```0``` выполняется предварительная агрегация данных с группировкой по полю ```l_orderkey``` (как это и указано в части ```GROUP BY```)
4. Далее данные перераспределяются (шаффл) в стадию ```1```, подробнее это обсуждается в следующем разделе
5. В стадии ```1``` выполняется финальная агрегация данных, дополнительная фильтрация (согласно условию ```HAVING```) и локальная сортировка
6. Последняя стадия ```2``` объединяет отсортированные потоки данных в одну глобально отсортированную последовательность, которая и возвращается в качестве результата

{% note tip %}

Если непонятно, что означает тот или иной графический элемент, спозиционируйте над ним указатель мыши. Большинство элементов имеют соответствующие подсказки с дополнительными пояснениями или уточнениями, которые будут показаны во всплывающем окне. Это не заменит детальное описание принятых символом и условностей, которые вы найдёте далее по тексту, то тоже поможет и сейчас, и в будущем.

{% endnote %}

## Каналы связи {#connections}

Теперь рассмотрим тот же самый запрос, но с точки зрения связи между отдельными стадиями. Если стадии - это вершины нашего графа вычислений, то есть ещё каналы связи, рёбра данного графа, обеспечивающие передачу данных между стадиями. У линейного графа выполнения, состоящего из 4 стадий обработки, имеет 3 соединения:

1. Соединение ```E``` это загрузка данных из хранилища (внешнего по отношению к компьюту)
2. Соединение ```H``` это hash shuffle, распределение данных по одному или нескольким полям (список полей будет показан во всплывающем окне при позиционировании курсора мыши над символом содеинения)
3. Соединение ```Me``` это операция объединения (merge) сортированных потоков данных. Для данного вида соединения также указывает поле (или несколько полей), в отношении которых происходит сортировка данных

Соединение показывается в виде пятиугольника, образного показываюшего направление передачи данных в графе. В данном экземпляре графа выделено соединение между стадиями ```0``` и ```1```.

![Каналы связи](../../_assets/rts-structure-2.svg)

Канал связи состоит из двух частей:

1. Выходной канал. В приведённом примере он передаёт исходящий трафик из стадии ```0```. Этот канал изображается синим цветом и направленной вправо и вверх стрелкой, на которой отображается номер стадии получателя, в данном случае ```1```.
2. Входной канал. В приведённом примере он принимает трафик в стадию ```1```. Канал изображается зеленым цветом и направленной влево и вверх стрелкой, на которой отображается номер стадии отправителя, в данном случае ```0```.

Объём переданных данных в исходящем и входящем каналах на графике успешно завершённого запроса должен совпадать, {{ ydb-short-name }} обеспечивает надёжную передачу данных между узлами, без потерь и появления дубликатов. Но агрегированные и временные характеристики могут существенно отличаться и предоставлять дополнительную информацию о том, как выполнялся запрос.

В процессе работы показатели исходящего и входящего канала могут не совпадать из-за естественного отставания входы от выхода и асинхронного режима обновления статистики выполнения запроса. Точно также график неуспешного запроса может содержать отличия между этими двумя группами метрик.

Кроме этого, важным элементом является соответствие входного канала и входа оператора. У нашем простом примере стадии содержат всего один входящий канал, соответственно данные которого приходят в этом канале связи, передаются на первый в очереди обработки (самый нижний в списке) оператор внутри стадии. Но в более сложных графах, стадии могут содержать несколько входов. Для того, чтобы точно понимать связи, в правой части оператора отображается тот же самый номер стадии с исходящим каналом, в данном случае это ```0``` и подсвечивается при выборе канала связи. Более наглядный пример будет показан в следующем разделе.

Чтобы подытожить пример, выбранный канал связи:

1. Начинается из стадии ```0``` в направлении стадии ```1```
2. Проходит через hash shuffle партиционирование
3. Приходит в стадию ```1``` из стадии ```0```
4. И попадает в оператор агрегации

Такие же каналы на логическом уровне существуют между стадией хранения и первой вычислительной стадией, куда этот трафик поступает. Они имеют технические особенности, отличающие их от каналов связи между двумя вычислительными стадиями, один из которых был рассмотрен выше. Например, планировщик {{ ydb-short-name }} старается располагать задачи из связанных таким каналом стадий на одних и тех же узлах, то есть размещать вычислительные задачи рядом с шардами хранения для минимизации сетевого трафика.

Но на верхнем уровне они очень похожи, поэтмоу визуализируеются схожим образом. Чтобы их быстро отличать они используют более тёмные тона, другие пиктограммы, а также не показывают номера парных стадий. На данный момент вычислительная стадия может быть связана только с одной стадией хранения, данные из которой всегда поступают в самый первый (нижний) оператор стадии, поэтому дополнительная навигация в данном случае не требуется и только лишь загромождала бы схему.

{% note tip %}

Выберите на графике и изучите соединение между внешней и вычислительной стадиями (показано как ```E```).

{% endnote %}

## Объединение стадий {#join}

![Объедиение стадий](../../_assets/rts-nation-region.svg)
